# Local functions
#################

# Summarize data 
# Good for making some quick visualizations of response that are grouped by Time and Group. 
# Not very flexible... 

summarizes_faces_1 <- function(data) {
  require(tidyverse)
  
  data %>% 
    
    # Deselect participant id
    select(-`Participant #`) %>%
    group_by(Time, Group) %>%
    
    # Summarise only the responses
    summarise_if(is_numeric, 
                 .funs = list('mean' = mean, 'med' = median, 
                              'rsd' = function(x, ...) sd(x, ...)/mean(x, ...)), 
                 na.rm = T) %>%
    ungroup() %>%
    
    # Taking the columns generated by the summary function
    pivot_longer(ends_with('mean') | ends_with('med') | ends_with('rsd'),
                 names_to = 'Category_Summary', values_to = 'Response') %>%
    
    # Parsing out the column headers
    separate(Category_Summary, into = c('Category', 'Summary'), sep = "_") %>%
    mutate(Category = str_replace(Category,'[:digit:]', '') %>% 
             str_replace('[:digit:]', '')  %>% 
             str_trim(side = 'both'),
           
           Category = factor(Category),
           Summary  = str_trim(Summary, side = 'both'),
           Summary  = factor(Summary),
           Group    = factor(Group),
           Time     = factor(Time, levels = c('Pre', 'Post')))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# nosey function
# Used to filter down groups quickly...
# Only used in EDA. Probably not robust.

nosey <- function(data, faces = T, group = 'Control', time = 'Post', Metric) {
  require(tidyverse)
  # Checks:
  # FACES should be logical
  if (!is_logical(faces)) stop('FACES arg should be logical.')
  
  # Group should be character and in column names
  if (!(group %in% colnames(data) | is.character(group))) stop('Group arg should be character of one of the column names.')
  
  # Same thing for Time
  if (!(time %in% colnames(data) | is.character(time))) stop('Time arg should be character of one of the column names.')
  
  # Same thing for metric
  if (!(Metric %in% colnames(data) | is.character(Metric))) stop('Time arg should be character of one of the column names.')
  
  data %>%
    filter(Group == group & Time == time & FACES == faces) %>%
    pull(Metric)
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# Format original faces data, function
# Make sure to use the following file: FACES_data_Spring_2019_AllData.csv
#   This comes from the google sheet Dr. Pearson shared.
# 


format_FACES <- function(data = NULL, path = NULL) {
  require(tidyverse)
  
  if (is.null(data) && is.null(path)) {
    path <- '../Data/FACES_data_Spring_2019_AllData.csv'
    data <- read_csv(path)
  } else if (!is.null(path)) {
    data <- read_csv(path)
  }
  
  data  %>%
    # Transform data so that all survey response are in 1 column, and
    # the corresponding survey is in another column (long data)
    pivot_longer(`FACES 1`:SEAS10, names_to = 'Survey', values_to = 'Response') %>%
    
    # Strip out the question number from the survey name
    # this standardizes survey names for ez grouping
    mutate(Survey = str_replace(Survey,'[:digit:]', '') %>% 
             str_replace('[:digit:]', '')  %>% 
             str_trim(side = 'both')) %>%
    
    # Group by (separate) participant number, time (pre vs post), group (exp vs control), and survey
    group_by(`Participant #`, Time, Group, Survey) %>%
    
    # Label the question number... might not be necessary...
    mutate(Question = row_number()) %>%
    
    ungroup()
}